<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Event Based Programming</title>

<meta name="description" content="explore logging with an emphasis on python">
<meta name="author" content="Kurt Neufeld &amp; Mike Warren">

<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro' rel='stylesheet' type='text/css'>

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"> -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimal-ui">

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/moon.css" id="theme">

<!-- Code syntax highlighting -->
<!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->
<link rel="stylesheet" href="lib/css/solarized_dark.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
      <![endif]-->


<style type="text/css">
.reveal li small { vertical-align: middle; }
.reveal img { vertical-align: middle; }
#who_is img { margin-right: 20px; }
dl { text-align: left; }
dl dt { text-align: left; }
dl dd { text-align: left; }

#link_slide a {
  font-size: 80%;
  font-family: 'Source Sans Pro';
}

img {
  background-color: white !important;
  text-shadow: none;
  border: none;
}

section
{
  text-align: left;
}

.small
{
  font-size: 75% !important;
}

.smallcaps, .caps {
  font-variant:small-caps !important;
}

.reveal pre {
  box-shadow: none;
  width: 100%;
}

tt, code, pre {
  font-family: 'Source Code Pro', monospace !important;
}

tt {
  color: #78bae6;
}

pre > code
{
  max-height: none !important;
}

.aside
{
  font-size: 75% !important;
  opacity: 0.5;
}

</style>

</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">

    <section>
      <h1>Event-Based Programming</h1>
      <hr/>
      <h2>Twisted and boost::asio</h2>
    </section>

    <section style="background-image: url(images/mike-transparent.svg); background-repeat: no-repeat; background-size: 300px; background-position: top right;">
      <!-- <img src="images/mike-transparent.svg" style="background: rgba(0, 0, 0, 0.0); width: 40%; height: auto; border: none; margin-left: 1em; float:right;" /> -->
      <!-- <object type="image/svg+xml" data="images/mike-transparent.svg" style="background: rgba(0, 0, 0, 0.0); width: 40%; height: auto; border: none; margin-left: 1em; float:right;"></object> -->
      <h2>Twisted <span class="small">via Python</span></h2>
      <p>Mike Warren</p>
      <p><a href="https://@meejah.ca">https://<span style="font-size: 150%; text-shadow: 2px 2px 1px rgba(0, 0, 0, 0.5); text-decoration: underline; -moz-text-decoration-color: rgba(255, 64, 64, 0.5);">@meejah</span>.ca</a></p>

      <div style="width: 1024px; margin-top: 150px;">
<!--
        <p class="fragment" style="opacity: 0.7; float: left;">
          <img src="images/txtorcon-logo.svg" style="box-shadow: none; border: none; background: none !important;" width="250" height="250" /><br />
          txtorcon.rtfd.org
        </p>
-->

<!--
        <p class="fragment" style="opacity: 0.7; float: left; margin-left: 4em;">
          <img src="images/crossbar.svg" style="padding-top: 25px; padding-bottom: 25px; box-shadow: none; border: none; background: none !important;" width="200" height="200" /><br />
          crossbar.io
        </p>
-->
      </div>
    </section>

    <section style="min-height: 30% !important; background-image: url(images/kurt.png); background-size: 300px; background-repeat: no-repeat; background-position: top right;">
      <h2>boost::asio <span class="small">via C++</span></h2>
      <p>Kurt Neufeld</p>
      <p><a href="http://www.burgundywall.com">burgundywall.com</a></p>
      <p><a href="https://twitter.com/kneufeld">@kneufeld</a></p>
    </section>

    <section>
      <h2>Talk Outline</h2>
      <ul>
        <li class="fragment">Event-Based Programming Overview</li>
        <li class="fragment">Demo chat server</li>
        <li class="fragment">Programming with Twisted</li>
        <li class="fragment">Programming with boost::asio</li>
      </ul>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <h2>Overview: background</h2>
      <ul>
        <li class="fragment">Two kinds of programs:</li>
        <ul>
          <li class="fragment">CPU-bound <span class="aside">(no waiting)</span></li>
          <li class="fragment">I/O-bound <span class="aside">(waiting)</span></li>
        </ul>
        <li class="fragment">Threading: CPU</li>
        <li class="fragment">Event based: I/O</li>
      </ul>
        <aside class="notes">
           mike: 2 kinds programs
           kurt: threading, event-based
        </aside>
    </section>

    <section>
      <h2>Definitions...</h2>
        <dl class="fragment">
          <dt><a href="http://en.wikipedia.org/wiki/Event_%28computing%29">event</a></dt>
          <dd><span class="aside">(verb)</span> an occurence requiring
            handling, usually with associated
            data <span class="aside">(network, timer, user input,
            etc)</span>
          </dd>
        </dl>
        <dl class="fragment">
          <dt><a href="http://en.wikipedia.org/wiki/Thread_%28computing%29">thread</a></dt>
          <dd><span class="aside">(noun)</span> a task that runs in parallel, blocking for I/O </dd>
        </dl>
        <dl class="fragment">
          <dt><a href="http://en.wikipedia.org/wiki/Context_switch">context switch</a></dt>
          <dd><span class="aside">(verb)</span> storing/restoring the state of a thread
          before/after getting <span class="caps">cpu</span> time. expensive. </dd>
        </dl>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <h2>Definitionsâ€¦</h2>
        <dl class="fragment">
          <dt><a href="http://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">syncronous</a></dt>
          <dd><span class="aside">(concept)</span> a blocking call, does not return until data or error
          <pre><code class="cpp">error = read(fd, buffer);</code></pre>
        </dd>
        </dl>
        <br/>
        <dl class="fragment">
          <dt><a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">asyncronous</a></dt>
          <dd><span class="aside">(concept)</span> a non-blocking
          call, returns instantly; callback happens <em>later</em>
          with data
          <pre><code data-trim class="cpp">
void callback(error, buffer) { /* ... */ }
read(fd, callback);
</code></pre></dd>
        </dl>
        <aside class="notes">
        </aside>
    </section>

    <section>
        <section data-transition="none">
          <h2>Threaded I/O</h2>
          <img src="images/threaded-io.svg" style="padding: 0.5em; height: 600px; border: none;">
            <aside class="notes">
            </aside>
        </section>

        <section data-transition="none">
          <h2>Threaded I/O</h2>
          <img src="images/threaded-io-contextswitches.svg" style="padding: 0.5em; height: 600px; border: none;">
            <aside class="notes">
            </aside>
        </section>
    </section>

    <section>
        <section data-transition="none">
          <h2>Event-based I/O</h2>
          <img src="images/event-based-io.svg" style="padding: 0.5em; height: 600px; border: none;">
            <aside class="notes">
            </aside>
        </section>

        <section data-transition="none">
          <h2>Event-based I/O</h2>
          <img src="images/event-based-io-arrows.svg" style="padding: 0.5em; height: 600px; border: none;">
            <aside class="notes">
            </aside>
        </section>
    </section>

    <section>
      <h2>Event-based vs. Threading</h2>
      <ul>
        <li class="fragment">OS resources</li>
        <li class="fragment">Context-switching <span class="aside">(latency, overhead)</span></li>
        <li class="fragment">Complexity</li>
        <li class="fragment">One core?! <span class="aside">(e.g. share socket)</span></li>
        <li class="fragment">Repeatability/testing</li>
      </ul>
        <aside class="notes">
        </aside>
    </section>

    <section data-state="moon">
      <h2>Event-Based Programming</h2>
      <ul>
        <li class="fragment">&ldquo;event&rdquo; &rarr; run code</li>
        <li class="fragment">event: timer, data received, data sent<br/><span class="aside">(network, user, disk, etc.)</span></li>
        <li class="fragment">code: &ldquo;callback&rdquo; <span class="aside">errback</span></li>
        <li class="fragment">unit-test callbacks, errbacks</li>
        <li class="fragment">Pattern: Reactor or Proactor</li>

<!--        <li class="fragment">Twisted: reactor</li>
        <li class="fragment">ASIO: both</li> -->
      </ul>
        <aside class="notes">
        </aside>
    </section>

<!--
    <section>
      <h2>What is event based programming?</h2>
      <p class="fragment">First some history...</p>
      <p class="fragment">Traditionally, scalability has been achieved by using
      multiple threads or multiple processes. Apache for instance, can be configured
      to use either.</p>
      <p class="fragment">Since threads can run concurrently in a
      single process, a well written threaded program can be extremely
      fast.</p>
      <p class="fragment">Unfortunately Amdahl's law states (basically) that there
      is always some part of a system that can't be parallelized and
      therefore infinite cores does not yield infinite speedup.</p>
      <p class="fragment">But mostly threads suck because threaded programming
      is <em>hard</em>.</p>
        <aside class="notes">
        </aside>
    </section>

    <section data-state="moon">
      <h2>What is event based programming?</h2>
      <div style="text-align: left">
        <dl class="fragment">
          <dt>event</dt>
          <dd>(noun)</dd>
        </dl>
      </div>
      <p class="fragment">Event based programs are based on a loop that sits
      around and waits for... events. An event can be a timer, network packet,
      mouse click, basically anything that the operating system can notify you
      about asynchronously.</p>
      <p class="fragment">A function that registers itself to be notified on a given
      event is named a <tt>callback</tt> and that callback handles the event.</p>
        <aside class="notes">
        </aside>
    </section>
-->

    <section>
      <h2>demo chat server <span class="aside">&amp; client</span></h2>
      <ul>
        <li class="fragment">msgpack encoding <span class="aside">(and framing)</span></li>
        <li class="fragment">list-of-strings: <code class="lang-python" style="font-size: 80% !important;">['nickname', 'insightful message']</code></li>
        <li class="fragment"><span class="caps">tcp</span> 10001</li>
        <li class="fragment"><tt>thula.meejah.ca:10001</tt></li>
      </ul>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <h2>chat server sequence</h2>
      <img src="images/msg_forward.png" height=500/>
        <aside class="notes">
        </aside>
    </section>

    <!-- set data-state to moon before/after setting solarized -->
    <section>
      <h2>twisted</h2>
<!--      <pre style="font-size: 100%;">git clone https://meejah.ca/polyglot-txchat</pre> -->
      <ul>
        <li class="fragment">https://twistedmatrix.com</li>
        <li class="fragment">Since 2001</li>
        <li class="fragment">330k Line of Code <span class="aside">(168k is tests)</span></li>
        <li class="fragment">TCP, UDP, ICMP â€¦ SSH, HTTPS, XMPP</li>
        <li class="fragment">Console, serial, GPS, timers â€¦</li>
        <li class="fragment">Servers or clients</li>
        <li class="fragment">Interop with other event-loops <span class="aside">(Qt, gtk, pygame, pyglet, asyncio, win32</span></span></li>
        <li class="fragment">Many, many other batteries are included</li>
      </ul>
      <aside class="notes">
        (longer than google!)
        protocols:
        XXX list moar protos here
      </aside>
        <aside class="notes">
        </aside>
    </section>

<!--
    <section>
      <h2>twisted</h2>
      <ul>
        <li class="fragment">Endpoints: <code>TCP4ServerEndpoint TCP4ClientEndpoint</code></li>
        <li class="fragment">Transports: <code>ITLSTransport ITCPTransport</code></li>
        <li class="fragment">Protocols: <code>ClientFactory, ServerFactory</code></li>
        <li class="fragment">Follow <code>IProtocol</code></li>
      </ul>
        <aside class="notes">
        </aside>
    </section>
-->
    <section data-transition="none">
      <h2>twisted infographic</h2>
      <img src="images/twisted-class-diagram.svg" style="padding: 0.5em; width: 1000px; border: none;">
        <aside class="notes">
        </aside>
    </section>

    <section> <!-- dep. injection -->
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre class="fragment"><code class="lang-python">class ChatSession(Protocol):</code></pre>
              <pre class="fragment"><code class="lang-python">    def connectionMade(self):
            pass</code></pre>
              <pre class="fragment"><code class="lang-python">    def connectionLost(self, reason):
            pass</code></pre>
<pre class="fragment"><code class="lang-python">    def dataReceived(self, data):
            pass</code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def connectionMade(self):
            pass

        def connectionLost(self, reason):
            pass

        def dataReceived(self, data):
            pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def connectionMade(self):
            global clients  # better ways, e.g. Factory

        def connectionLost(self, reason):
            pass

        def dataReceived(self, data):
            pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def connectionMade(self):
            global clients  # better ways, e.g. Factory
            clients.add(self)

        def connectionLost(self, reason):
            pass

        def dataReceived(self, data):
            pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def connectionMade(self):
            global clients
            clients.add(self)

        def connectionLost(self, reason):
            global clients
            clients.remove(self)

        def dataReceived(self, data):
            pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            msg = self.decoder.next()
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            try:
                msg = self.decoder.next()
            except StopIteration:
                print("No message yet.")
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                # handle msg
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            pass
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            packed = msgpack.packb(msg)
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            packed = msgpack.packb(msg)
            global clients
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            packed = msgpack.packb(msg)
            global clients
            for proto in clients:
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        # ...
        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            packed = msgpack.packb(msg)
            global clients
            for proto in clients:
                proto.transport.write(packed)
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
                self.gotMessage(msg)

        def gotMessage(self, msg):
            global clients
            packed = msgpack.packb(msg)
            for proto in clients:
                proto.transport.write(packed)
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">class ChatSession(Protocol):
        def __init__(self):
            self.decoder = msgpack.Unpacker()

        def dataReceived(self, data):
            self.decoder.feed(data)
            for msg in self.decoder:
               self.gotMessage(msg)

        def gotMessage(self, msg):
            global clients
            packed = msgpack.packb(msg)
            for proto in clients:
                proto.transport.write(packed)

        def connectionMade(self):
            global clients
            clients.add(self)

        def connectionLost(self, reason):
            global clients
            clients.remove(self)
          </code></pre>
        <aside class="notes">
        </aside>
        </section>
    </section>

    <section> <!-- Factory -->
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        pass
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()

def main(reactor):
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()

def main(reactor):
    endpoint = TCP4ServerEndpoint(reactor, 10001)
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()

def main(reactor):
    endpoint = TCP4ServerEndpoint(reactor, 10001)
    endpoint.listen(ChatFactory())
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()

def main(reactor):
    endpoint = TCP4ServerEndpoint(reactor, 10001)
    endpoint.listen(ChatFactory())
    return Deferred()  # loop forever
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>server protocol</h2>
              <pre><code class="lang-python">
class ChatFactory(Factory):
    def buildProtocol(self, addr):
        return ChatSession()

def main(reactor):
    endpoint = TCP4ServerEndpoint(reactor, 10001)
    endpoint.listen(ChatFactory())
    return Deferred()  # loop forever

react(main)  # from twisted.internet.task
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
    </section>


    <section> <!-- client protocol -->
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
        for msg in self.unpacker:
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
        for msg in self.unpacker:
            print("{}: {}".format(*tuple(msg)))
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
        for msg in self.unpacker:
            print("{}: {}".format(*tuple(msg)))

    def sendMessage(self, nick, data):
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
        for msg in self.unpacker:
            print("{}: {}".format(*tuple(msg)))

    def sendMessage(self, nick, data):
        data = msgpack.packb([nick, msg])
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
        <section data-transition="none">
          <h2>client protocol</h2>
              <pre><code class="lang-python">class ChatClient(Protocol):
    def __init__(self, done):
        self.done = done
        self.unpacker = msgpack.Unpacker()

    def connectionLost(self, reason):
        self.done.callback(reason)

    def dataReceived(self, data):
        self.unpacker.feed(data)
        for msg in self.unpacker:
            print("{}: {}".format(*tuple(msg)))

    def sendMessage(self, nick, data):
        data = msgpack.packb([nick, msg])
        self.transport.write(data)
              </code></pre>
        <aside class="notes">
        </aside>
        </section>
    </section>

    <section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        return self.protocol.sendMessage(self.nick, line)

        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        return self.protocol.sendMessage(self.nick, line)

    def __init__(self, nick, proto):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        return self.protocol.sendMessage(self.nick, line)

    def __init__(self, nick, proto):
        self.nick = nick
        self.protocol = proto
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        return self.protocol.sendMessage(self.nick, line)

    def __init__(self, nick, proto):
        self.nick = nick
        self.protocol = proto

    def connectionLost(self, reason):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>user input</h2>
        <pre><code class="lang-python">from twisted.protocols.basic import LineReceiver
from twisted.internet.stdio import StandardIO
class StandardInput(LineReceiver, StandardIO):
    delimiter = os.linesep
    def lineReceived(self, line):
        return self.protocol.sendMessage(self.nick, line)

    def __init__(self, nick, proto):
        self.nick = nick
        self.protocol = proto

    def connectionLost(self, reason):
        self.protocol.transport.loseConnection()
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section>

    <section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">from twisted.test import proto_helpers
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">from twisted.test import proto_helpers
import pytest
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">from twisted.test import proto_helpers
import pytest

@pytest.fixture(scope='function')
def proto(factory):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">from twisted.test import proto_helpers
import pytest

@pytest.fixture(scope='function')
def proto(factory):
    transport = proto_helpers.StringTransportWithDisconnection()
        </code></pre>
      <aside class="notes">
        Only important thing: test-controlled TRANSPORT!!
      </aside>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">from twisted.test import proto_helpers
import pytest

@pytest.fixture(scope='function')
def proto(factory):
    transport = proto_helpers.StringTransportWithDisconnection()
    p = factory.buildProtocol(IPv4Address(...))
    transport.protocol = p
    p.makeConnection(transport)
    return p
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_two_messages_at_once(proto):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_two_messages_at_once(proto):
    # set up
    test_message0 = ['ZoP', 'Beautiful is better than ugly.']
    test_message1 = ['ZoP', 'Explicit is better than implicit.']
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_two_messages_at_once(proto):
    # set up
    test_message0 = ['ZoP', 'Beautiful is better than ugly.']
    test_message1 = ['ZoP', 'Explicit is better than implicit.']
    data = msgpack.packb(test_message0)
    data += msgpack.packb(test_message1)
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_two_messages_at_once(proto):
    # set up
    test_message0 = ['ZoP', 'Beautiful is better than ugly.']
    test_message1 = ['ZoP', 'Explicit is better than implicit.']
    data = msgpack.packb(test_message0)
    data += msgpack.packb(test_message1)

    # send our test-messages over the protocol, all at once
    proto.dataReceived(data)
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_two_messages_at_once(proto):
    # ...

    # server just echos message to all connected clients
    unpacker = msgpack.Unpacker()
    unpacker.feed(proto.transport.value())
    messages = list(unpacker)
    assert len(messages) == 2
    assert messages[0] == test_message0
    assert messages[1] == test_message1
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
    test_message = ['albert', 'The only source of knowledge is experience.']
    data = msgpack.packb(test_message)
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
    test_message = ['albert', 'The only source of knowledge is experience.']
    data = msgpack.packb(test_message)

    # send our message in two chunks
    proto.dataReceived(data[:5])
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
    test_message = ['albert', 'The only source of knowledge is experience.']
    data = msgpack.packb(test_message)

    # send our message in two chunks
    proto.dataReceived(data[:5])
    assert proto.transport.value() == ''
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
    test_message = ['albert', 'The only source of knowledge is experience.']
    data = msgpack.packb(test_message)

    # send our message in two chunks
    proto.dataReceived(data[:5])
    assert proto.transport.value() == ''
    proto.dataReceived(data[5:])
        </code></pre>
      <aside class="notes">
        state-machine walking!
      </aside>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h2>Testing!</h2>
        <pre><code class="lang-python">def test_message_trickle(proto):
    test_message = ['albert', 'The only source of knowledge is experience.']
    data = msgpack.packb(test_message)

    # send our message in two chunks
    proto.dataReceived(data[:5])
    assert proto.transport.value() == ''
    proto.dataReceived(data[5:])

    # server just echos message to all connected clients
    sent_data = proto.transport.value()
    assert msgpack.unpackb(sent_data) == test_message
        </code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section>

    <section>
      <section data-transition="none">
        <h2>Test Runner</h2>
        <pre><code class="nohighlight">$ py.test test/test_*.py
===================== test session starts =====================
platform linux2 -- Python 2.7.8 -- py-1.4.26 -- pytest-2.6.4
plugins: cov
collected 9 items

test/test_client.py ....
test/test_server.py .....

================== 9 passed in 0.04 seconds ==================
</code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section>

    <section data-state="moon">
      <h2>boost::asio</h2>
      <div style="text-align: left">
      <dl class="fragment">
        <dt>boost</dt>
        <dd>the greatest open source c++ library ever</dd>
        <dd><em>lots</em> of pieces, <tt>asio</tt> is just one of them</dd>
      </dl>
      <dl class="fragment">
        <dt>asio</dt>
        <dd>asynchronous input/output</dd>
        <dd>a cross-platform C++ library for network and low-level I/O programming</dd>
      </dl>
    </div>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <h2>asio connection sequence</h2>
      <p>simplified</p>
      <img src="images/tcp_start.png" height=500/>
        <aside class="notes">
        </aside>
    </section>

    <section data-transition="none">
      <h3>asio client <span class="aside">msgpack object</span></h3>
      <pre><code class="cpp">class chat_message
{
public:

  std::string nickname;
  std::string message;

  MSGPACK_DEFINE( nickname, message );
};</code></pre>
        <aside class="notes">
          mention cross-language encoding<br/>
          like json but binary
        </aside>
    </section>

    <section id="cpp_client_code">
      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="lang-cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="lang-cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
public:
    posix_chat_client(
        boost::asio::io_service& io_service,
        tcp::resolver::iterator endpoint_iterator,
        std::string nickname );
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
public:
    posix_chat_client(
        boost::asio::io_service& io_service,
        tcp::resolver::iterator endpoint_iterator,
        std::string nickname );

private:
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
public:
    posix_chat_client(
        boost::asio::io_service& io_service,
        tcp::resolver::iterator endpoint_iterator,
        std::string nickname );

private:

    void handle_connect( const error_code& ec );
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
public:
    posix_chat_client(
        boost::asio::io_service& io_service,
        tcp::resolver::iterator endpoint_iterator,
        std::string nickname );

private:

    void handle_connect( const error_code& ec );

    void listen_on_socket();
    void cb_read_socket( const error_code& ec, std::size_t bytes_recv );
    void cb_write_socket( const error_code& ec, std::size_t length );
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">header</span></h3>
        <pre><code class="cpp">using boost::system::error_code;

class posix_chat_client // equiv to txchat.ChatClient
{
public:
    posix_chat_client(
        boost::asio::io_service& io_service,
        tcp::resolver::iterator endpoint_iterator,
        std::string nickname );

private:

    void handle_connect( const error_code& ec );

    void listen_on_socket();
    void cb_read_socket( const error_code& ec, std::size_t bytes_recv );
    void cb_write_socket( const error_code& ec, std::size_t length );

    void listen_on_input();
    void cb_read_input( const error_code& ec, std::size_t length );

    tcp::socket m_socket;
    // other member variables etc
};</code></pre>
        <aside class="notes">
        </aside>
      </section>

        <aside class="notes">
        </aside>
    </section>

    <section>
      <section data-transition="none">
        <h3>asio client <span class="aside">constructor</span></h3>
        <pre><code class="c++">posix_chat_client::posix_chat_client( asio::io_service& io_service,
                                      tcp::resolver::iterator endpoint_iterator,
                                      std::string nickname )
    : m_socket( io_service ),
      m_stdin( io_service, ::dup( STDIN_FILENO ) ),
      m_stdout( io_service, ::dup( STDOUT_FILENO ) ),
      m_input_buffer( max_msg_length )
{
    m_nickname = nickname;

    // attempt to connect to server, call handle_connect when we do
    auto handler = boost::bind( &posix_chat_client::handle_connect, this,
                                asio::placeholders::error );
    asio::async_connect( m_socket, endpoint_iterator, handler );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">connect</span></h3>
        <pre><code class="c++">void posix_chat_client::handle_connect( const error_code& ec )
{
    if( error )
    {
        std::cerr << "could not connect to " << m_socket.remote_endpoint() << std::endl;
        return;
    }

    listen_on_socket();
    listen_on_input();
}</code></pre>
        <aside class="notes">
          Assume going forward I'm always checking error codes and doing something
          appropriate like logging and exiting.
        </aside>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">listen</span></h3>
        <pre><code class="c++">void posix_chat_client::listen_on_socket()
{
    // read from socket
    auto buffer = asio::buffer( m_read_buffer, 1024 );
    auto handler = boost::bind( &posix_chat_client::cb_read_socket, this,
                                asio::placeholders::error,
                                asio::placeholders::bytes_transferred );

    m_socket.async_read_some( buffer, handler );
}</code></pre>
        <pre class="fragment"><code class="c++">void posix_chat_client::listen_on_input()
{
    // read from console until newline
    auto handler = boost::bind( &posix_chat_client::cb_read_input, this,
                                asio::placeholders::error,
                                asio::placeholders::bytes_transferred );

    asio::async_read_until( m_stdin, m_input_buffer, '\n', handler );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">read callback</span></h3>
        <pre><code class="c++">void posix_chat_client::cb_read_socket( const error_code& ec,
                                        std::size_t bytes_recv )
{
    if( error ) ; // handle it and return

    if( feed_to_unpacker( m_read_buffer, bytes_recv ) )
    {
        // sync write out the message we just received, terminated by a newline.
        auto buffer = asio::buffer( output.data(), output.size() );
        asio::write( m_stdout, m_packer.buffer() );
    }

    listen_on_socket(); // read more bytes
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">console callback</span></h3>
        <pre><code class="c++">void posix_chat_client::cb_read_input( const error_code& ec, std::size_t length )
{
    if( error ) ; // handle it and return

    // pack up user's string

    auto buffer = asio::buffer( m_packer.data(), m_packer.size() );
    auto handler = boost::bind( &posix_chat_client::cb_write_socket, this, asio::placeholders::error, asio::placeholders::bytes_transferred );
    asio::async_write( m_socket, buffer, handler );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio client <span class="aside">write callback</span></h3>
        <pre><code class="c++">void posix_chat_client::cb_write_socket( const error_code& ec, std::size_t length )
{
    if( error ) ; // handle it and return
    listen_on_input();
}</code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section><!-- cpp_client_code -->

    <section id="cpp_server_code">
      <section data-transition="none">
        <h3>asio server <span class="aside">session</span></h3>
        <pre><code class="cpp">// equiv to txchat.ChatSession
class chat_session : public std::enable_shared_from_this&lt;chat_session>
{
public:
    typedef std::shared_ptr&lt;chat_session> pointer;

    chat_session( tcp::socket socket, chat_room& room );
    ~chat_session();

    void deliver( const chat_message& msg );

private:
    void do_read();
    void do_write();

    tcp::socket m_socket;
    // buffers, packer and unpacker
};</code></pre>
        <aside class="notes">
           <p>The majority of the work happens in the <code>chat_session</code></p>
           <p>But we need to see how we accept a connection first</p>
           <p>Server is written in C++11 style</p>
        </aside>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio server <span class="aside">session manager</span></h3>
        <pre><code class="cpp">// equiv to "global txchat.clients"
class chat_room
{
public:

    chat_room( std::string name );

    void join( chat_session::pointer member );
    void leave( chat_session::pointer member );
    void deliver( chat_session::pointer sender, const chat_message& msg );

private:
    typedef std::set&lt;chat_session::pointer> member_set;
    member_set      m_members;
    std::string     m_name;
};</code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section>

    <section>
      <section data-transition="none">
        <h3>asio server <span class="aside">acceptor</span></h3>
        <pre><code class="cpp">// equiv to txchat.ChatFactory
class chat_server
{
public:
    chat_server( boost::asio::io_service& io_service,
                 const tcp::endpoint& endpoint );

private:
    void do_accept();

    tcp::acceptor m_acceptor;
    tcp::socket   m_socket;
    chat_room     m_room;
};</code></pre>
        <aside class="notes">
        </aside>
      </section>
      <section data-transition="none">
        <h3>asio server <span class="aside">acceptor</span></h3>
        <pre><code class="cpp">void chat_server::do_accept()
{
    m_acceptor.async_accept( m_socket,
    // this is a C++11 lambda (aka anonymous function)
    [this]( error_code ec )
    {
        if( ec )
        {
            TL_S_ERROR << "accept error: " << ec.message();
        }
        else
        {
            TL_S_INFO << "accepted connection from: " << m_socket.remote_endpoint();
            auto session = std::make_shared&lt;chat_session>( std::move( m_socket ), m_room );
            session->do_read();
        }

        do_accept();
    } );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section>

      <section data-transition="none">
        <h3>asio server <span class="aside">read from socket</span></h3>
        <pre><code class="cpp">void chat_session::do_read()
{
    auto self( shared_from_this() );
    auto buffer = boost::asio::buffer( m_read_buff.data(), 1024 ),

    m_socket.async_read_some( buffer,
    [this, self]( error_code ec, std::size_t length )
    {
        if( ec ) ; // handle it and exit, breaking the listen chain

        // feed incoming bytes to unpacker
        // actual code is different, but this is close enough for a demo
        if( m_unpacker.feed( m_read_buff, length ) )
        {
            m_unpacker.convert( &m_msg );
            m_room.deliver( self, m_msg ); // send to other clients
        }

        do_read();
    } );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio server <span class="aside">write to socket</span></h3>
        <pre><code class="cpp">void chat_session::do_write()
{
    msgpack::pack( m_packer, m_msg ); // pack our msg

    auto self( shared_from_this() );
    auto buffer = boost::asio::buffer( m_packer.data(), m_packer.size() );

    boost::asio::async_write( m_socket, buffer,
    [this, self]( error_code ec, std::size_t length )
    {
        if( ec ) ; // handle it and close
        // log and increment counters
    } );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio server <span class="aside">close &amp; cleanup</span></h3>
        <pre><code class="cpp">void chat_session::close()
{
    error_code ec;
    m_socket.cancel(ec);

    // this is why we have the goofy creation order
    // we need need to tell our parent to erase us
    auto self( shared_from_this() );
    m_room.leave( self );
}</code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section data-transition="none">
        <h3>asio server <span class="aside">main</span></h3>
        <pre><code class="cpp">int main( int argc, char** argv )
{
    // parse command line with boost::program_options
    // setup signal handler to catch ctrl-c

    try
    {
        boost::asio::io_service ios;

        for( auto port : opts["ports"].as< std::vector&lt;unsigned> >() )
        {
            tcp::endpoint endpoint( tcp::v4(), port );
            servers.emplace_back( ios, endpoint );
        }

        ios.run(); // this blocks "forever"
    }
    catch( std::exception& e )
    {
        cerr << "there was a catastrophic failure: " << e.what() << endl;
        return 1;
    }

    return 0;
}</code></pre>
        <aside class="notes">
        </aside>
      </section>
    </section><!-- cpp_server_code -->

    <section>
      <h2>C++ "extras"</h2>
      <ul>
        <li>using <code>boost::logging</code> for... logging</li>
        <li>using <code>boost::program_options</code> to parse command line</li>
        <li><code>msgpack</code> example code</li>
        <li><code>boost::asio</code> with C++11 example code</li>
        <li><tt>hammer</tt> client mixes threads and events</li>
      </ul>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <h2>Performance</h2>
      <div style="float: left">
        <table>
          <tr class="fragment" data-fragment-index=1>
            <td>server</td>
            <td>8-core Xeon E3 <span class="aside">3.4GHz w/</span> 16GiB RAMz</td>
          </tr>
          <tr class="fragment" data-fragment-index=2>
            <td>clients</td>
            <td>32</td>
          </tr>
          <tr class="fragment" data-fragment-index=2>
            <td>send delay</td>
            <td>1ms</td>
          </tr>
          <tr class="fragment" data-fragment-index=2>
            <td>msg size</td>
            <td>21 bytes</td>
          </tr>
          <tr class="fragment" data-fragment-index=3>
            <td>total messages</td>
            <td>â‰ˆ56M</td>
          </tr>
          <tr class="fragment" data-fragment-index=4>
            <td>C++ msg/sec</td>
            <td>â‰ˆ1M</td>
          </tr>
          <tr class="fragment" data-fragment-index=5>
            <td>PyPy msg/sec</td>
            <td>â‰ˆ1M</td>
          </tr>
        </table>
      </div>
        <aside class="notes">
        </aside>
    </section>

    <section>
      <section data-transition="none">
        <h2>Demo</h2>
        <dl>
          <dt>Twisted server</dt>
          <dd><code class="nohighlight">thula.meejah.ca:10001</code></dd>
        </dl>
        <dl>
          <dt>C++ server</dt>
          <dd><code class="nohighlight">polyglot.burgundywall.com:10001</code></dd>
        </dl>

      <pre><code class="nohighlight"># Twisted client
$ txchat client --nick meejah
$ txchat client --nick meejah --endpoint tcp:polyglot.burgundywall.com:10001

# C++ client
$ client kurt thula.meejah.ca 10001
$ client kurt polyglot.burgundywall.com 10001
</code></li>
        <aside class="notes">
        </aside>
      </section>
    </section>



    <section style="text-align: left;">
      <h1>THE END</h1>
      <div class="fragment">
        <h3>Thanks in part to..</h3>
        <ul>
          <li><a href="https://twistedmatrix.com/trac/">Twisted</a></li>
          <li><a href="http://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio.html">boost::asio</a></li>
          <li><a href="http://lab.hakim.se/reveal-js/">reveal.js</a></li>
        </ul>
      </div>
        <aside class="notes">
        </aside>
    </section>

    <section style="text-align: center">
      <h1>You Guys!</h1>
      <h3 class="fragment">(and polyglot)</h3>
        <aside class="notes">
        </aside>
    </section>

    <section style="text-align: center" id="link_slide">
      <h3>presentation</h3>
      <h3><a href="http://polyglot.burgundywall.com">http://polyglot.burgundywall.com</a></h3>

      <h4>C++ code</h4>
      <h3>
        <a href="https://github.com/kneufeld/chatroom">https://github.com/kneufeld/chatroom</a>
      </h3>

      <h4>twisted code</h4>
      <p>
        install txchat:
        <pre><code class="nohighlight">
virtualenv poly
source ./poly/bin/activate
pip install https://meejah.ca/poly/txchat-1.0.0.tar.gz
txchat --help
        </code></pre>
      </p>
      <aside class="notes">
      </aside>
    </section>

  </div><!-- slides -->

</div!-- reveal -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: false,
mouseWheel: false,
slideNumber: true,

width: 1024,
height: 768,
//fragments: false,

transition: 'slide', // none/fade/slide/convex/concave/zoom

// Optional reveal.js plugins
dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'plugin/zoom-js/zoom.js', async: true },
{ src: 'plugin/notes/notes.js', async: true }
]
});

Reveal.addEventListener('moon', function() {
  document.getElementById('theme').setAttribute('href','css/theme/moon.css');
    });
Reveal.addEventListener('solarized', function() {
  document.getElementById('theme').setAttribute('href','css/theme/solarized.css');
    });
</script>

</body>
</html>
